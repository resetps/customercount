<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ÎÇ¥ÏõêÏàò ÎåÄÏãúÎ≥¥Îìú</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
  <style>
    :root{
      --bg:#f4f6f8;
      --panel:#ffffff;
      --border:#e5e7eb;
      --text:#111827;
      --muted:#6b7280;
      --accent:#2563eb;
      --success:#10b981;
      --warning:#f59e0b;
      --danger:#ef4444;
    }
    [data-theme="dark"]{
      --bg:#0f172a;
      --panel:#1e293b;
      --border:#334155;
      --text:#f1f5f9;
      --muted:#94a3b8;
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Arial,sans-serif;
      background:var(--bg);
      color:var(--text);
      transition:background 0.3s,color 0.3s;
    }
    .topbar{
      position:sticky;
      top:0;
      z-index:10;
      background:var(--panel);
      border-bottom:1px solid var(--border);
      box-shadow:0 1px 3px rgba(0,0,0,0.05);
    }
    .topbar-inner{
      max-width:1800px;
      margin:0 auto;
      padding:20px 32px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:16px;
      flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-size:32px;
      font-weight:900;
      display:flex;
      align-items:center;
      gap:12px;
    }
    .sub{
      font-size:14px;
      color:var(--muted);
      margin-top:4px;
    }
    .theme-toggle{
      width:44px;
      height:44px;
      border-radius:50%;
      border:1px solid var(--border);
      background:var(--panel);
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:20px;
      transition:transform 0.2s;
    }
    .theme-toggle:hover{ transform:scale(1.1); }
    .filters-row{
      display:flex;
      gap:14px;
      align-items:flex-end;
      flex-wrap:wrap;
    }
    .tabs{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin:6px 0 18px;
    }
    .tab-btn{
      height:38px;
      padding:0 16px;
      font-size:14px;
      border-radius:999px;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      cursor:pointer;
      font-weight:700;
      transition:all 0.2s;
    }
    .tab-btn:hover{
      background:var(--accent);
      color:#fff;
      border-color:var(--accent);
    }
    .tab-btn.active{
      background:var(--accent);
      color:#fff;
      border-color:var(--accent);
      box-shadow:0 6px 12px rgba(37,99,235,0.2);
    }
    .presets{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .preset-btn{
      height:36px;
      padding:0 12px;
      font-size:13px;
      border-radius:8px;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
      cursor:pointer;
      font-weight:600;
      transition:all 0.2s;
    }
    .preset-btn:hover{
      background:var(--accent);
      color:#fff;
      border-color:var(--accent);
    }
    label{
      font-size:14px;
      color:var(--muted);
      display:block;
      margin-bottom:6px;
      font-weight:600;
    }
    input,button{
      height:48px;
      font-size:16px;
      padding:0 14px;
      border-radius:10px;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
    }
    button{
      font-weight:800;
      background:var(--accent);
      color:#fff;
      cursor:pointer;
      transition:all 0.2s;
    }
    button:hover{ opacity:0.9; transform:translateY(-1px); }
    button:disabled{ opacity:.6; cursor:not-allowed; transform:none; }
    .ghost{
      background:transparent;
      color:var(--text);
      border:1px solid var(--border);
    }
    .ghost:hover{
      background:var(--accent);
      color:#fff;
      border-color:var(--accent);
    }
    .wrap{
      max-width:1800px;
      margin:0 auto;
      padding:32px;
    }
    .cards{
      display:grid;
      grid-template-columns:repeat(4,1fr);
      gap:20px;
      margin:28px 0;
    }
    .card{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      padding:28px;
      transition:all 0.3s;
      position:relative;
      overflow:hidden;
    }
    .card:hover{
      transform:translateY(-4px);
      box-shadow:0 8px 16px rgba(0,0,0,0.1);
    }
    .card .t{
      font-size:18px;
      color:var(--muted);
      font-weight:600;
    }
    .card .v{
      font-size:48px;
      font-weight:900;
      margin-top:12px;
    }
    .grid{
      display:grid;
      grid-template-columns:500px 1fr;
      gap:20px;
      margin-bottom:20px;
    }
    .grid-full{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:20px;
      margin-bottom:20px;
    }
    .panel{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:16px;
      padding:24px;
      min-width:0;
    }
    .panel h2{
      margin:0 0 16px;
      font-size:20px;
      font-weight:800;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    .panel-sub{
      font-size:13px;
      color:var(--muted);
      font-weight:600;
    }
    .panel-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      margin-bottom:8px;
    }
    .panel-actions{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .btn-sm{
      height:36px;
      padding:0 12px;
      font-size:14px;
      border-radius:8px;
    }
    .btn-danger{
      background:var(--danger);
      border-color:var(--danger);
      color:#fff;
    }
    .btn-danger.ghost{
      background:transparent;
      color:var(--danger);
      border-color:var(--danger);
    }
    .btn-danger.ghost:hover{
      background:var(--danger);
      color:#fff;
      border-color:var(--danger);
    }
    .chart-container{
      position:relative;
      height:450px;
      margin-top:10px;
    }
    table{ width:100%; border-collapse:collapse; }
    thead th{
      position:sticky;
      top:0;
      background:linear-gradient(180deg,#f8fafc 0%,#f1f5f9 100%);
      font-size:15px;
      font-weight:800;
      padding:16px 14px;
      border-bottom:3px solid var(--accent);
      border-right:1px solid var(--border);
      text-align:center;
      white-space:nowrap;
      cursor:pointer;
      user-select:none;
      text-transform:uppercase;
      letter-spacing:0.5px;
      color:var(--text);
      box-shadow:0 2px 4px rgba(0,0,0,0.05);
    }
    thead th:last-child{ border-right:none; }
    [data-theme="dark"] thead th{
      background:linear-gradient(180deg,var(--panel) 0%,#0f172a 100%);
      border-bottom-color:var(--accent);
    }
    thead th:hover{
      background:var(--accent);
      color:#fff;
      transition:all 0.2s;
    }
    thead th:first-child{ text-align:center; font-weight:700; }
    thead th .sort-icon{ margin-left:6px; opacity:0.4; font-size:14px; }
    thead th.sorted .sort-icon{ opacity:1; }
    tbody td{
      font-size:15px;
      padding:14px;
      border-bottom:1px solid var(--border);
      border-right:1px solid var(--border);
      text-align:center;
      transition:background 0.15s;
    }
    tbody td:last-child{ border-right:none; }
    tbody tr:nth-child(odd){ background:var(--panel); }
    tbody tr:nth-child(even){ background:#f8fafc; }
    [data-theme="dark"] tbody tr:nth-child(even){ background:rgba(255,255,255,0.03); }
    tbody tr:hover{
      background:rgba(37,99,235,0.08);
      box-shadow:inset 0 0 0 1px rgba(37,99,235,0.2);
    }
    tbody td:first-child{
      background:rgba(37,99,235,0.08);
      color:var(--accent);
      font-weight:700;
      border-right:2px solid var(--accent);
    }
    tbody td:nth-child(2){
      font-weight:700;
      background:rgba(16,185,129,0.05);
    }
    tbody td:not(:first-child){ font-variant-numeric:tabular-nums; }
    .scroll{ max-height:720px; overflow:auto; width:100%; }
    .scroll table{ min-width:100%; width:max-content; }
    #dailyWrap tbody tr{ cursor:pointer; }
    #dailyWrap tbody tr.selected{
      background:rgba(37,99,235,0.18);
      box-shadow:inset 0 0 0 2px rgba(37,99,235,0.45);
    }
    .msg{
      font-size:14px;
      color:var(--muted);
      margin-bottom:10px;
      padding:12px;
      background:var(--panel);
      border-radius:8px;
      border:1px solid var(--border);
    }
    .msg[data-kind="error"]{ color:var(--danger); border-color:rgba(239,68,68,0.4); }
    .msg[data-kind="success"]{ color:var(--success); border-color:rgba(16,185,129,0.4); }
    .entry-panel{ margin-bottom:24px; }
    .entry-grid{ display:grid; gap:16px; }
    .entry-fields{ width:100%; }
    .entry-scroll{ overflow-x:auto; }
    .entry-table{ width:100%; border-collapse:collapse; }
    .entry-table th,
    .entry-table td{
      border:1px solid var(--border);
      padding:8px;
      text-align:center;
      white-space:nowrap;
    }
    .entry-table th{
      background:#f8fafc;
      font-weight:700;
    }
    [data-theme="dark"] .entry-table th{
      background:rgba(255,255,255,0.04);
    }
    .entry-table input{
      width:100%;
      height:36px;
      font-size:14px;
      padding:0 8px;
      border-radius:8px;
      border:1px solid var(--border);
      background:var(--panel);
      color:var(--text);
    }
    .entry-table .total-cell{
      background:rgba(16,185,129,0.08);
      font-weight:700;
    }
    .entry-table input[readonly]{
      background:rgba(16,185,129,0.08);
      font-weight:700;
    }
    .entry-actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:16px;
    }
    .foreign-header-manager{
      border:1px dashed var(--border);
      border-radius:12px;
      padding:14px;
      background:rgba(37,99,235,0.04);
    }
    .foreign-header-tools{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      margin-bottom:8px;
    }
    .foreign-header-tools input{
      height:40px;
      min-width:220px;
      flex:1;
    }
    .foreign-header-tools button{
      height:40px;
      min-width:100px;
      padding:0 12px;
      font-size:14px;
    }
    .foreign-header-list{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .foreign-chip{
      display:inline-flex;
      align-items:center;
      gap:8px;
      border:1px solid var(--border);
      border-radius:999px;
      padding:6px 10px;
      background:var(--panel);
      font-size:13px;
      font-weight:600;
    }
    .foreign-chip button{
      height:26px;
      min-width:auto;
      padding:0 8px;
      border-radius:999px;
      font-size:12px;
      font-weight:700;
      background:transparent;
      color:var(--danger);
      border:1px solid rgba(239,68,68,0.45);
    }
    .foreign-chip button:hover{
      background:var(--danger);
      color:#fff;
      border-color:var(--danger);
      transform:none;
    }
    .foreign-chip .fixed{
      display:inline-flex;
      align-items:center;
      height:22px;
      padding:0 8px;
      border-radius:999px;
      font-size:11px;
      color:var(--muted);
      border:1px solid var(--border);
    }
    .divider{ height:1px; background:var(--border); margin:18px 0; }
    .hidden{ display:none; }
    @media (max-width:1100px){
      .grid{ grid-template-columns:1fr; }
      .grid-full{ grid-template-columns:1fr; }    }
    @media (max-width:900px){ .cards{ grid-template-columns:repeat(2,1fr); } }
    @media (max-width:600px){
      .cards{ grid-template-columns:1fr; }
      h1{ font-size:22px; }
      .topbar-inner{ padding:14px 16px; }
      .wrap{ padding:16px; }
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="topbar-inner">
      <div>
        <h1>ÎÇ¥ÏõêÏàò ÎåÄÏãúÎ≥¥Îìú<button class="theme-toggle" id="themeToggle" title="ÌÖåÎßà Ï†ÑÌôò">üåô</button></h1>
        <div class="sub">Í∏∞Í∞Ñ ÏÑ†ÌÉù ÌõÑ Îç∞Ïù¥ÌÑ∞ ÏßëÍ≥Ñ</div>
      </div>
      <div class="filters-row">
        <div class="presets">
          <button class="preset-btn" onclick="setPreset('today')">Ïò§Îäò</button>
          <button class="preset-btn" onclick="setPreset('week')">ÏµúÍ∑º 7Ïùº</button>
          <button class="preset-btn" onclick="setPreset('month')">Ïù¥Î≤à Îã¨</button>
          <button class="preset-btn" onclick="setPreset('lastMonth')">ÏßÄÎÇú Îã¨</button>
        </div>
        <div>
          <label>ÏãúÏûëÏùº</label>
          <input id="startDate" type="date" />
        </div>
        <div>
          <label>Ï¢ÖÎ£åÏùº</label>
          <input id="endDate" type="date" />
        </div>
        <div>
          <label>&nbsp;</label>
          <button id="btn" onclick="load()">Ï°∞Ìöå</button>
        </div>
        <div>
          <label>&nbsp;</label>
          <button class="ghost" id="toggleEntry">ÏûÖÎ†• Î™®Îìú</button>
        </div>
      </div>
    </div>
  </div>
  <div class="wrap">
    <div class="tabs" id="tabs">
      <button class="tab-btn active" data-tab="visits">ÎÇ¥ÏõêÏàò</button>
      <button class="tab-btn" data-tab="surgery">ÏàòÏà†Ïàò</button>
      <button class="tab-btn" data-tab="foreign">Ïô∏Íµ≠Ïù∏</button>
    </div>
    <div id="msg" class="msg"></div>
    <div id="entryPanel" class="panel entry-panel hidden">
      <h2><span id="entryTitle">ÏûÖÎ†• Î™®Îìú</span><span class="panel-sub" id="entrySub">ÏùºÎ≥Ñ Îç∞Ïù¥ÌÑ∞Î•º Ï∂îÍ∞Ä/ÏàòÏ†ïÌï©ÎãàÎã§.</span></h2>
      <div class="entry-grid">
        <div id="entryFields" class="entry-fields"></div>
        <div id="foreignHeaderManager" class="foreign-header-manager hidden">
          <label for="foreignHeaderInput">Ïô∏Íµ≠Ïù∏ Íµ≠Í∞Ä Ìï≠Î™© Í¥ÄÎ¶¨</label>
          <div class="foreign-header-tools">
            <input id="foreignHeaderInput" type="text" placeholder="Ï∂îÍ∞ÄÌï† Íµ≠Í∞ÄÎ™Ö ÏûÖÎ†• (Ïòà: Ï∫êÎÇòÎã§)" />
            <button class="ghost" id="btnAddForeignHeader" type="button">Ìï≠Î™© Ï∂îÍ∞Ä</button>
          </div>
          <div class="panel-sub">Ï¥ù Ïô∏Íµ≠Ïù∏ ÏàòÎäî ÏûêÎèô Í≥ÑÏÇ∞ÎêòÎ©∞, ÏÇ≠Ï†ú Ïãú Ìï¥Îãπ Íµ≠Í∞Ä Í∞íÏùÄ Î™®Îì† ÎÇ†ÏßúÏóêÏÑú Ï†úÍ±∞Îê©ÎãàÎã§.</div>
          <div id="foreignHeaderList" class="foreign-header-list"></div>
        </div>
      </div>
      <div class="entry-actions">
        <button id="btnEntrySave">Ï†ÄÏû•</button>
        <button class="ghost" id="btnEntryClear">Ï¥àÍ∏∞Ìôî</button>
      </div>
    </div>
    <div class="cards" id="cards"></div>
    <div class="panel" style="margin-bottom:20px;">
      <h2 id="totalTrendTitle">ÏùºÎ≥Ñ Ï¥ù ÎÇ¥ÏõêÏàò Ï∂îÏÑ∏</h2>
      <div class="chart-container" style="height:280px;">
        <canvas id="totalBarChart"></canvas>
      </div>
    </div>
    <div class="grid-full">
      <div class="panel">
        <h2 id="topTrendTitle">ÏùºÎ≥Ñ ÏÉÅÏúÑ Ï±ÑÎÑê Ï∂îÏÑ∏</h2>
        <div class="chart-container">
          <canvas id="trendChart"></canvas>
        </div>
      </div>
      <div class="panel">
        <h2 id="pieTitle">Ï±ÑÎÑêÎ≥Ñ Î∂ÑÌè¨</h2>
        <div class="chart-container">
          <canvas id="pieChart"></canvas>
        </div>
      </div>
    </div>
    <div class="grid">
      <div class="panel">
        <h2 id="sumTitle">Ï±ÑÎÑêÎ≥Ñ Ìï©Í≥Ñ</h2>
        <table>
          <thead>
            <tr>
              <th onclick="sortTable('sumBody', 0)" id="sumHeaderLabel"><span class="sum-header-text">Ï±ÑÎÑê</span> <span class="sort-icon">‚Üï</span></th>
              <th onclick="sortTable('sumBody', 1)">Ìï©Í≥Ñ <span class="sort-icon">‚Üï</span></th>
            </tr>
          </thead>
          <tbody id="sumBody"></tbody>
        </table>
      </div>
      <div class="panel">
        <div class="panel-head">
          <h2 id="dailyTitle">ÏùºÏûêÎ≥Ñ ÏÉÅÏÑ∏</h2>
          <div class="panel-actions">
            <button class="btn-danger ghost" id="btnDeleteRow" type="button">ÎÇ†Ïßú ÏÇ≠Ï†ú</button>
          </div>
        </div>
        <div class="scroll" id="dailyWrap"></div>
      </div>
    </div>
  </div>
  <script>
    const firebaseConfig = {
      apiKey: "AIzaSyA5Qekw67qpMcZjEU9jXAkIzyZBZNFZp2E",
      authDomain: "reset-92637.firebaseapp.com",
      databaseURL: "https://reset-92637-default-rtdb.firebaseio.com",
      projectId: "reset-92637",
      storageBucket: "reset-92637.firebasestorage.app",
      messagingSenderId: "436716760537",
      appId: "1:436716760537:web:74705fea8463e59728fdc8",
      measurementId: "G-BCRNP4WMEY"
    };
    const DB_ROOT = "customer_count";
    const DATA_MODE = "firebase";
    const STORAGE_KEY = "customer_count_local";
        const OLD_SEARCH_LABEL = "\uC778\uD130\uB137 \uAC80\uC0C9";
        const NAVER_SEARCH_LABEL = "\uAC80\uC0C9(\uB124\uC774\uBC84)";
        const OLD_META_LABEL = "\uBA54\uD0C0";
    const OLD_GOOGLE_AD_LABEL = "";
    const GOOGLE_AD_LABEL = "\uAD11\uACE0(\uAD6C\uAE00)";
    const META_LABEL = "\uAD11\uACE0(\uBA54\uD0C0)";
    const GOOGLE_SEARCH_LABEL = "\uAC80\uC0C9(\uAD6C\uAE00)";
            const DEFAULT_HEADER = [
      "\uCD1D \uB0B4\uC6D0 \uC218",
      "\uAC80\uC0C9(\uB124\uC774\uBC84)",
      "\uAC80\uC0C9(\uAD6C\uAE00)",
      "\uD648\uD398\uC774\uC9C0",
      "\uAC15\uB0A8\uC5B8\uB2C8",
      "\uBC14\uBE44\uD1A1",
      "SNS",
      "\uBE14\uB85C\uADF8",
      "\uCE74\uD398",
      "\uC18C\uAC1C",
      "\uC6CC\uD06C\uC778",
      "\uC720\uD29C\uBE0C",
      "\uB9AC\uC5BC\uBAA8\uB378",
      "\uD574\uC678 \uC5D0\uC774\uC804\uC2DC",
      "\uAD11\uACE0(\uBA54\uD0C0)",
      "\uAD11\uACE0(\uAD6C\uAE00)",
      "\uAE30\uD0C0"
    ];
    const DEFAULT_FOREIGN_HEADER = [
      "\uC678\uAD6D\uC778 \uC218",
      "\uC77C\uBCF8",
      "\uD0DC\uAD6D",
      "\uBBF8\uAD6D",
      "\uC911\uAD6D",
      "\uBCA0\uD2B8\uB0A8",
      "\uD638\uC8FC",
      "\uBABD\uACE8",
      "\uB77C\uC624\uC2A4",
      "\uB300\uB9CC",
      "\uB124\uB35C\uB780\uB4DC",
      "\uAE30\uD0C0"
    ];
    const PLACEHOLDER_FOREIGN_HEADER = [
      "\uC678\uAD6D\uC778 \uC218",
      "\uAD6D\uAC001",
      "\uAD6D\uAC002",
      "\uAD6D\uAC003",
      "\uAE30\uD0C0"
    ];
    const FOREIGN_ETC_LABEL = "\uAE30\uD0C0";
    const TAB_VISITS = "visits";
    const TAB_SURGERY = "surgery";
    const TAB_FOREIGN = "foreign";
    const TAB_META = {
      [TAB_VISITS]: {
        label: "\uB0B4\uC6D0\uC218",
        totalLabel: "\uCD1D \uB0B4\uC6D0 \uC218",
        groupLabel: "\uCC44\uB110",
        totalTrendTitle: "\uC77C\uBCC4 \uCD1D \uB0B4\uC6D0\uC218 \uCD94\uC138",
        topTrendTitle: "\uC77C\uBCC4 \uC0C1\uC704 \uCC44\uB110 \uCD94\uC138",
        distributionTitle: "\uCC44\uB110\uBCC4 \uBD84\uD3EC",
        sumTitle: "\uCC44\uB110\uBCC4 \uD569\uACC4",
        entryTitle: "\uB0B4\uC6D0\uC218 \uC785\uB825 \uBAA8\uB4DC",
        entrySub: "\uC77C\uBCC4 \uB0B4\uC6D0\uC218/\uACBD\uB85C \uB370\uC774\uD130\uB97C \uCD94\uAC00/\uC218\uC815\uD569\uB2C8\uB2E4.",
        toggleEntryLabel: "\uB0B4\uC6D0\uC218 \uC785\uB825 \uBAA8\uB4DC"
      },
      [TAB_SURGERY]: {
        label: "\uC218\uC220\uC218",
        totalLabel: "\uCD1D \uC218\uC220 \uC218",
        groupLabel: "\uCC44\uB110",
        totalTrendTitle: "\uC77C\uBCC4 \uCD1D \uC218\uC220\uC218 \uCD94\uC138",
        topTrendTitle: "\uC77C\uBCC4 \uC0C1\uC704 \uCC44\uB110 \uCD94\uC138",
        distributionTitle: "\uCC44\uB110\uBCC4 \uBD84\uD3EC",
        sumTitle: "\uCC44\uB110\uBCC4 \uD569\uACC4",
        entryTitle: "\uC218\uC220\uC218 \uC785\uB825 \uBAA8\uB4DC",
        entrySub: "\uC77C\uBCC4 \uC218\uC220\uC218/\uACBD\uB85C \uB370\uC774\uD130\uB97C \uCD94\uAC00/\uC218\uC815\uD569\uB2C8\uB2E4.",
        toggleEntryLabel: "\uC218\uC220\uC218 \uC785\uB825 \uBAA8\uB4DC"
      },
      [TAB_FOREIGN]: {
        label: "\uC678\uAD6D\uC778",
        totalLabel: "\uC678\uAD6D\uC778 \uC218",
        groupLabel: "\uAD6D\uAC00",
        totalTrendTitle: "\uC77C\uBCC4 \uC678\uAD6D\uC778 \uCD94\uC138",
        topTrendTitle: "\uC77C\uBCC4 \uC0C1\uC704 \uAD6D\uAC00 \uCD94\uC138",
        distributionTitle: "\uAD6D\uAC00\uBCC4 \uBD84\uD3EC",
        sumTitle: "\uAD6D\uAC00\uBCC4 \uD569\uACC4",
        entryTitle: "\uC678\uAD6D\uC778 \uC785\uB825 \uBAA8\uB4DC",
        entrySub: "\uC77C\uBCC4 \uC678\uAD6D\uC778/\uAD6D\uAC00 \uB370\uC774\uD130\uB97C \uCD94\uAC00/\uC218\uC815\uD569\uB2C8\uB2E4.",
        toggleEntryLabel: "\uC678\uAD6D\uC778 \uC785\uB825 \uBAA8\uB4DC"
      }
    };
    const EMBEDDED_CSV = "ÎÇ¥Ïõê Ïàò,,,,,,,,,,,,,,,,Í∏∞Í∞Ñ,,\n,,,,,,,,,,,,,,,,2025-12-03,2025-12-31,‚ÜêÍ∏∞Í∞Ñ Î≥Ñ ÌïÑÌÑ∞ÎßÅ\nÌï©Í≥Ñ,150,19,5,33,24,6,0,5,13,0,4,4,5,27,5,,,\nÎÇ†Ïßú,Ï¥ù ÎÇ¥Ïõê Ïàò,Í≤ÄÏÉâ(ÎÑ§Ïù¥Î≤Ñ),Í≤ÄÏÉâ(Íµ¨Í∏Ä),ÌôàÌéòÏù¥ÏßÄ,Í∞ïÎÇ®Ïñ∏Îãà,Î∞îÎπÑÌÜ°,SNS,Î∏îÎ°úÍ∑∏,Ïπ¥Ìéò,ÏÜåÍ∞ú,ÏõåÌÅ¨Ïù∏,Ïú†ÌäúÎ∏å,Î¶¨ÏñºÎ™®Îç∏,Ìï¥Ïô∏ ÏóêÏù¥Ï†ÑÏãú,Í¥ëÍ≥†(Î©îÌÉÄ),Í¥ëÍ≥†(Íµ¨Í∏Ä),Í∏∞ÌÉÄ,,,\n2025.1.1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,,,\n2025.1.2,11,0,0,0,1,2,1,0,0,2,0,0,0,2,3,0,0,,,\n2025.1.3,11,2,0,0,3,0,1,0,0,0,0,0,1,0,4,0,0,,,\n2025.1.4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,,,\n2025.1.5,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,,,\n2025.1.6,13,1,0,0,2,1,0,0,1,1,0,4,1,0,1,0,1,,,\n2025.1.7,9,2,0,0,1,0,0,0,0,3,0,0,0,0,3,0,0,,,\n2025.1.8,7,1,0,0,0,0,0,0,0,2,0,0,1,0,2,0,1,,,\n2025.1.9,12,1,0,1,8,0,0,0,0,1,0,0,0,0,1,0,0,,,\n2025.1.10,6,2,0,1,1,0,0,0,0,0,0,0,0,0,2,0,0,,,\n2025.1.11,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,,,\n2025.1.12,8,0,0,1,1,3,1,0,0,1,0,0,0,1,0,0,0,,,\n2025.1.13,12,0,0,0,4,3,0,0,1,0,0,0,1,0,2,0,1,,,\n2025.1.14,14,3,0,1,4,3,0,0,0,1,0,0,0,0,2,0,0,,,\n2025.1.15,7,2,0,0,1,1,1,0,0,1,0,0,0,0,1,0,0,,,\n2025.1.16,5,1,0,0,2,1,0,0,0,0,0,0,0,1,0,0,0,,,\n2025.1.17,5,0,0,0,2,2,0,0,0,0,0,0,0,0,1,0,0,,,\n2025.1.18,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,,,\n2025.1.19,6,1,0,1,0,1,0,0,2,0,0,0,0,0,1,0,0,,,\n2025.1.20,8,1,0,0,1,3,1,0,0,0,0,0,0,1,1,0,0,,,\n2025.1.21,6,1,0,0,0,1,1,0,1,0,0,0,0,0,2,0,0,,,\n2025.1.22,5,1,0,0,1,1,0,0,0,0,0,0,0,0,1,0,1,,,\n2025.1.23,5,0,0,0,1,2,0,0,0,1,0,0,0,0,0,0,1,,,\n2025.1.24,0,,0,,,,,,,,,,,,,0,,,,\n2025.1.25,0,,0,,,,,,,,,,,,,0,,,,\n2025.1.26,0,,0,,,,,,,,,,,,,0,,,,\n2025.1.27,0,,0,,,,,,,,,,,,,0,,,,\n2025.1.28,0,,0,,,,,,,,,,,,,0,,,,\n2025.1.29,0,,0,,,,,,,,,,,,,0,,,,\n2025.1.30,0,,0,,,,,,,,,,,,,0,,,,\n2025.1.31,0,,0,,,,,,,,,,,,,0,,,,\n";
    const initializeApp = firebase.initializeApp;
    const getDatabase = () => firebase.database();
    const ref = (dbInstance, path) => dbInstance.ref(path);
    const onValue = (refObj, cb) => refObj.on("value", cb);
    const set = (refObj, value) => refObj.set(value);
    const update = (refObj, value) => refObj.update(value);
    const remove = (refObj) => refObj.remove();
    const serverTimestamp = () => firebase.database.ServerValue.TIMESTAMP;
    const app = initializeApp(firebaseConfig);
    const db = getDatabase(app);
    const state = { header: [], foreignHeader: [], rowsByDate: {}, rows: [] };
    let trendChart;
    let pieChart;
    let totalBarChart;
    let hasCustomRange = false;
    let seedAttempted = false;
    let headerEmpty = true;
    let foreignHeaderEmpty = true;
    let rowsEmpty = true;
    let migratedSearchColumns = false;
    let isUpdatingTotal = false;
    let activeTab = TAB_VISITS;
    const startInput = document.getElementById("startDate");
    const endInput = document.getElementById("endDate");
    const entryPanel = document.getElementById("entryPanel");
    let entryDateInput = document.getElementById("entryDate");
    const entryFields = document.getElementById("entryFields");
    const btnEntrySave = document.getElementById("btnEntrySave");
    const btnEntryClear = document.getElementById("btnEntryClear");
    const btnDeleteRow = document.getElementById("btnDeleteRow");
    const toggleEntryBtn = document.getElementById("toggleEntry");
    const themeToggle = document.getElementById("themeToggle");
    const foreignHeaderManager = document.getElementById("foreignHeaderManager");
    const foreignHeaderInput = document.getElementById("foreignHeaderInput");
    const btnAddForeignHeader = document.getElementById("btnAddForeignHeader");
    const foreignHeaderList = document.getElementById("foreignHeaderList");
    let selectedDateISO = "";
    let isUpdatingForeignHeader = false;
    function fmt(n){ return Number(n || 0).toLocaleString(); }
    function setMsg(text, kind){
      const el = document.getElementById("msg");
      el.textContent = text || "";
      el.dataset.kind = kind || "";
    }
    function getActiveMeta(){
      return TAB_META[activeTab] || TAB_META[TAB_VISITS];
    }
    function getSurgeryHeader(){
      return (state.header || []).map(name => String(name || "").replace(/\uB0B4\uC6D0/g, "\uC218\uC220"));
    }
    function getHeaderByTab(tab){
      if (tab === TAB_FOREIGN) return state.foreignHeader;
      if (tab === TAB_SURGERY) return getSurgeryHeader();
      return state.header;
    }
    function getActiveHeader(){
      return getHeaderByTab(activeTab);
    }
    function getMetricsKeyByTab(tab){
      if (tab === TAB_FOREIGN) return "foreignMetrics";
      if (tab === TAB_SURGERY) return "surgeryMetrics";
      return "metrics";
    }
    function getActiveMetricsKey(){
      return getMetricsKeyByTab(activeTab);
    }
    function isPlaceholderForeignHeader(header){
      if (!Array.isArray(header) || header.length !== PLACEHOLDER_FOREIGN_HEADER.length) return false;
      return PLACEHOLDER_FOREIGN_HEADER.every((name, idx) => String(header[idx] || "").trim() === name);
    }
    function normalizeForeignHeader(header){
      if (!Array.isArray(header)) return [];
      const cleaned = header.map(name => (String(name || "").trim() === "\uBAAC\uACE8" ? "\uBABD\uACE8" : name));
      const hasTaiwan = cleaned.some(name => String(name || "").trim() === "\uB300\uB9CC");
      if (!hasTaiwan){
        const otherIdx = cleaned.findIndex(name => String(name || "").trim() === "\uB124\uB35C\uB780\uB4DC");
        const etcIdx = cleaned.findIndex(name => String(name || "").trim() === "\uAE30\uD0C0");
        const insertIdx = otherIdx >= 0 ? otherIdx : (etcIdx >= 0 ? etcIdx : cleaned.length);
        cleaned.splice(insertIdx, 0, "\uB300\uB9CC");
      }
      return cleaned;
    }
    function normalizeCategoryName(value){
      return String(value || "").trim().replace(/\s+/g, " ");
    }
    function getForeignEtcIndex(header){
      return header.findIndex(name => normalizeCategoryName(name) === FOREIGN_ETC_LABEL);
    }
    function isForeignCategoryRemovable(header, index){
      const totalIdx = findTotalIndex(header, TAB_META[TAB_FOREIGN].totalLabel);
      if (index === totalIdx) return false;
      const nonTotalCount = header.filter((_, idx) => idx !== totalIdx).length;
      return nonTotalCount > 1;
    }
    function remapForeignRows(nextHeader){
      const prevHeader = Array.isArray(state.foreignHeader) ? state.foreignHeader : [];
      const totalLabel = TAB_META[TAB_FOREIGN].totalLabel;
      const prevTotalIdx = findTotalIndex(prevHeader, totalLabel);
      const nextTotalIdx = findTotalIndex(nextHeader, totalLabel);
      const remappedRows = {};
      Object.entries(state.rowsByDate || {}).forEach(([dateISO, payload]) => {
        const basePayload = (payload && typeof payload === "object" && !Array.isArray(payload)) ? payload : {};
        const visitMetrics = basePayload.metrics !== undefined
          ? basePayload.metrics
          : normalizeMetrics(payload, state.header.length);
        const prevForeignMetrics = normalizeMetrics(basePayload.foreignMetrics || [], prevHeader.length);
        const nextForeignMetrics = new Array(nextHeader.length).fill(0);
        nextHeader.forEach((name, idx) => {
          if (idx === nextTotalIdx) return;
          const prevIdx = prevHeader.findIndex((oldName, oldIdx) => (
            oldIdx !== prevTotalIdx && normalizeCategoryName(oldName) === normalizeCategoryName(name)
          ));
          if (prevIdx >= 0){
            nextForeignMetrics[idx] = prevForeignMetrics[prevIdx] || 0;
          }
        });
        applyComputedTotal(nextForeignMetrics, nextHeader, totalLabel);
        remappedRows[dateISO] = { ...basePayload, metrics: visitMetrics, foreignMetrics: nextForeignMetrics };
      });
      return remappedRows;
    }
    function renderForeignHeaderManager(){
      if (!foreignHeaderManager || !foreignHeaderList) return;
      const show = activeTab === TAB_FOREIGN;
      foreignHeaderManager.classList.toggle("hidden", !show);
      if (!show) return;
      const header = Array.isArray(state.foreignHeader) ? state.foreignHeader : [];
      foreignHeaderList.innerHTML = "";
      header.forEach((name, idx) => {
        const chip = document.createElement("div");
        chip.className = "foreign-chip";
        const label = document.createElement("span");
        label.textContent = name;
        chip.appendChild(label);
        if (isForeignCategoryRemovable(header, idx)){
          const removeBtn = document.createElement("button");
          removeBtn.type = "button";
          removeBtn.textContent = "ÏÇ≠Ï†ú";
          removeBtn.dataset.removeIndex = String(idx);
          removeBtn.disabled = isUpdatingForeignHeader;
          chip.appendChild(removeBtn);
        }else{
          const fixed = document.createElement("span");
          fixed.className = "fixed";
          fixed.textContent = "Í≥†Ï†ï";
          chip.appendChild(fixed);
        }
        foreignHeaderList.appendChild(chip);
      });
      if (foreignHeaderInput){
        foreignHeaderInput.disabled = isUpdatingForeignHeader;
      }
      if (btnAddForeignHeader){
        btnAddForeignHeader.disabled = isUpdatingForeignHeader;
      }
    }
    async function applyForeignHeaderChange(nextHeader){
      const totalLabel = TAB_META[TAB_FOREIGN].totalLabel;
      let normalized = (nextHeader || [])
        .map(normalizeCategoryName)
        .filter(Boolean);
      const totalIdx = normalized.findIndex(name => name === totalLabel);
      if (totalIdx < 0){
        normalized.unshift(totalLabel);
      }else if (totalIdx !== 0){
        normalized.splice(totalIdx, 1);
        normalized.unshift(totalLabel);
      }
      const seen = new Set();
      normalized = normalized.filter(name => {
        const key = name.toLowerCase();
        if (seen.has(key)) return false;
        seen.add(key);
        return true;
      });
      if (normalized.length < 2){
        setMsg("ÏµúÏÜå 1Í∞ú Íµ≠Í∞Ä Ìï≠Î™©ÏùÄ ÌïÑÏöîÌï©ÎãàÎã§.", "error");
        return false;
      }
      normalized = normalizeForeignHeader(normalized);
      isUpdatingForeignHeader = true;
      renderForeignHeaderManager();
      try{
        const remappedRows = remapForeignRows(normalized);
        if (DATA_MODE === "local"){
          const store = loadLocalStore();
          store.header = state.header;
          store.foreignHeader = normalized;
          store.rows = remappedRows;
          saveLocalStore(store);
          applyLocalStore(store, getEmbeddedData());
          setMsg("Ïô∏Íµ≠Ïù∏ Ìï≠Î™©ÏùÑ Î∞òÏòÅÌñàÏäµÎãàÎã§.", "success");
          return true;
        }
        const foreignHeaderRef = ref(db, `${DB_ROOT}/meta/foreignHeader`);
        const rowsRef = ref(db, `${DB_ROOT}/rows`);
        const rowPatch = {};
        Object.entries(remappedRows).forEach(([dateISO, payload]) => {
          rowPatch[dateISO] = { ...payload, updatedAt: serverTimestamp() };
        });
        await set(foreignHeaderRef, normalized);
        if (Object.keys(rowPatch).length){
          await update(rowsRef, rowPatch);
        }
        setMsg("Ïô∏Íµ≠Ïù∏ Ìï≠Î™©ÏùÑ Î∞òÏòÅÌñàÏäµÎãàÎã§.", "success");
        return true;
      }catch(err){
        setMsg(`Ïô∏Íµ≠Ïù∏ Ìï≠Î™© Î∞òÏòÅ Ïã§Ìå®: ${err.message || err}`, "error");
        return false;
      }finally{
        isUpdatingForeignHeader = false;
        renderForeignHeaderManager();
      }
    }
    async function addForeignHeaderItem(){
      if (activeTab !== TAB_FOREIGN){
        setMsg("Ïô∏Íµ≠Ïù∏ ÌÉ≠ÏóêÏÑúÎßå Íµ≠Í∞Ä Ìï≠Î™©ÏùÑ Í¥ÄÎ¶¨Ìï† Ïàò ÏûàÏäµÎãàÎã§.", "error");
        return;
      }
      if (isUpdatingForeignHeader) return;
      const inputName = normalizeCategoryName(foreignHeaderInput ? foreignHeaderInput.value : "");
      if (!inputName){
        setMsg("Ï∂îÍ∞ÄÌï† Íµ≠Í∞ÄÎ™ÖÏùÑ ÏûÖÎ†•ÌïòÏÑ∏Ïöî.", "error");
        return;
      }
      const exists = state.foreignHeader.some(name => normalizeCategoryName(name).toLowerCase() === inputName.toLowerCase());
      if (exists){
        setMsg("Ïù¥ÎØ∏ ÏûàÎäî Íµ≠Í∞Ä Ìï≠Î™©ÏûÖÎãàÎã§.", "error");
        return;
      }
      const nextHeader = [...state.foreignHeader];
      const insertIdx = getForeignEtcIndex(nextHeader);
      nextHeader.splice(insertIdx >= 0 ? insertIdx : nextHeader.length, 0, inputName);
      const saved = await applyForeignHeaderChange(nextHeader);
      if (saved && foreignHeaderInput){
        foreignHeaderInput.value = "";
        foreignHeaderInput.focus();
      }
    }
    async function removeForeignHeaderItem(removeIndex){
      if (activeTab !== TAB_FOREIGN) return;
      if (isUpdatingForeignHeader) return;
      const header = [...state.foreignHeader];
      if (!Number.isInteger(removeIndex) || removeIndex < 0 || removeIndex >= header.length) return;
      if (!isForeignCategoryRemovable(header, removeIndex)){
        setMsg("Ìï¥Îãπ Ìï≠Î™©ÏùÄ ÏÇ≠Ï†úÌï† Ïàò ÏóÜÏäµÎãàÎã§.", "error");
        return;
      }
      const targetName = header[removeIndex];
      if (!confirm(`'${targetName}' Ìï≠Î™©ÏùÑ ÏÇ≠Ï†úÌï†ÍπåÏöî?`)) return;
      header.splice(removeIndex, 1);
      await applyForeignHeaderChange(header);
    }
    function updateTabUI(){
      const meta = getActiveMeta();
      document.querySelectorAll(".tab-btn").forEach(btn => {
        btn.classList.toggle("active", btn.dataset.tab === activeTab);
      });
      const totalTrendTitle = document.getElementById("totalTrendTitle");
      if (totalTrendTitle) totalTrendTitle.textContent = meta.totalTrendTitle;
      const topTrendTitle = document.getElementById("topTrendTitle");
      if (topTrendTitle) topTrendTitle.textContent = meta.topTrendTitle;
      const pieTitle = document.getElementById("pieTitle");
      if (pieTitle) pieTitle.textContent = meta.distributionTitle;
      const sumTitle = document.getElementById("sumTitle");
      if (sumTitle) sumTitle.textContent = meta.sumTitle;
      const sumHeaderText = document.querySelector("#sumHeaderLabel .sum-header-text");
      if (sumHeaderText) sumHeaderText.textContent = meta.groupLabel;
      const entryTitle = document.getElementById("entryTitle");
      if (entryTitle) entryTitle.textContent = meta.entryTitle;
      const entrySub = document.getElementById("entrySub");
      if (entrySub) entrySub.textContent = meta.entrySub;
      if (toggleEntryBtn) toggleEntryBtn.textContent = meta.toggleEntryLabel;
      renderForeignHeaderManager();
    }
    function setActiveTab(tab){
      if (!TAB_META[tab] || tab === activeTab) return;
      activeTab = tab;
      localStorage.setItem("activeTab", activeTab);
      updateTabUI();
      buildEntryFields();
      renderAll();
    }
    function normalizeHeader(raw){
      if (!raw) return [];
      if (Array.isArray(raw)){
        return raw.map(v => String(v || "").trim()).filter(Boolean);
      }
      return Object.keys(raw)
        .sort((a, b) => Number(a) - Number(b))
        .map(key => String(raw[key] || "").trim())
        .filter(Boolean);
    }
    function migrateSearchColumns(header, rowsByDate){
      if (!header || !header.length) return { header, rowsByDate, migrated: false };
      const idx = header.indexOf(OLD_SEARCH_LABEL);
      if (idx < 0) return { header, rowsByDate, migrated: false };
      const nextHeader = [...header];
      nextHeader[idx] = NAVER_SEARCH_LABEL;
      nextHeader.splice(idx + 1, 0, GOOGLE_SEARCH_LABEL);
      const nextRows = {};
      Object.entries(rowsByDate || {}).forEach(([dateISO, payload]) => {
        const hasMetrics = payload && typeof payload === "object" && !Array.isArray(payload) && Array.isArray(payload.metrics);
        const base = hasMetrics ? payload.metrics : payload;
        const metrics = normalizeMetrics(base, header.length);
        metrics.splice(idx + 1, 0, 0);
        nextRows[dateISO] = hasMetrics ? { ...payload, metrics } : metrics;
      });
      return { header: nextHeader, rowsByDate: nextRows, migrated: true };
    }
    function migrateMetaLabel(header, rowsByDate){
      if (!header || !header.length) return { header, rowsByDate, migrated: false };
      const idx = header.indexOf(OLD_META_LABEL);
      if (idx < 0) return { header, rowsByDate, migrated: false };
      const nextHeader = [...header];
      nextHeader[idx] = META_LABEL;
      return { header: nextHeader, rowsByDate, migrated: true };
    }
    function migrateGoogleAdColumn(header, rowsByDate){
      if (!header || !header.length) return { header, rowsByDate, migrated: false };
      const metaIdx = header.indexOf(META_LABEL);
      if (metaIdx < 0) return { header, rowsByDate, migrated: false };
      if (header.includes(GOOGLE_AD_LABEL)) return { header, rowsByDate, migrated: false };
      const nextHeader = [...header];
      nextHeader.splice(metaIdx + 1, 0, GOOGLE_AD_LABEL);
      const nextRows = {};
      Object.entries(rowsByDate || {}).forEach(([dateISO, payload]) => {
        const hasMetrics = payload && typeof payload === "object" && !Array.isArray(payload) && Array.isArray(payload.metrics);
        const base = hasMetrics ? payload.metrics : payload;
        const metrics = normalizeMetrics(base, header.length);
        metrics.splice(metaIdx + 1, 0, 0);
        nextRows[dateISO] = hasMetrics ? { ...payload, metrics } : metrics;
      });
      return { header: nextHeader, rowsByDate: nextRows, migrated: true };
    }

    function toNumber(v){
      if (v === null || v === undefined || v === "") return 0;
      if (typeof v === "number") return v;
      const n = Number(String(v).replace(/,/g, ""));
      return Number.isNaN(n) ? 0 : n;
    }
    function normalizeMetrics(metrics, len){
      if (!len) return [];
      let arr = [];
      if (Array.isArray(metrics)){
        arr = metrics;
      }else if (metrics && typeof metrics === "object"){
        arr = Object.keys(metrics)
          .sort((a, b) => Number(a) - Number(b))
          .map(key => metrics[key]);
      }
      const out = new Array(len).fill(0);
      for (let i = 0; i < Math.min(arr.length, len); i++){
        out[i] = toNumber(arr[i]);
      }
      return out;
    }
    function parseDateString(value){
      if (!value) return null;
      if (Object.prototype.toString.call(value) === "[object Date]" && !Number.isNaN(value.getTime())){
        return new Date(value.getFullYear(), value.getMonth(), value.getDate());
      }
      const str = String(value).trim();
      const m = str.match(/^(\\d{4})[.\\/-](\\d{1,2})[.\\/-](\\d{1,2})/);
      if (m){
        return new Date(Number(m[1]), Number(m[2]) - 1, Number(m[3]));
      }
      const compact = str.match(/^(\\d{4})(\\d{2})(\\d{2})$/);
      if (compact){
        return new Date(Number(compact[1]), Number(compact[2]) - 1, Number(compact[3]));
      }
      const d = new Date(str);
      if (!Number.isNaN(d.getTime())){
        return new Date(d.getFullYear(), d.getMonth(), d.getDate());
      }
      return null;
    }
    function formatISO(date){
      const y = date.getFullYear();
      const m = String(date.getMonth() + 1).padStart(2, "0");
      const d = String(date.getDate()).padStart(2, "0");
      return `${y}-${m}-${d}`;
    }
    function formatLabel(date){
      const y = date.getFullYear();
      const m = date.getMonth() + 1;
      const d = date.getDate();
      return `${y}.${m}.${d}`;
    }
    function findTotalIndex(header, totalLabel){
      if (!header || !header.length) return -1;
      if (totalLabel){
        const exactIdx = header.findIndex(name => String(name || "").trim() === totalLabel);
        if (exactIdx >= 0) return exactIdx;
      }
      let idx = header.findIndex(name => /\uCD1D\s*\uB0B4\uC6D0/i.test(name));
      if (idx >= 0) return idx;
      idx = header.findIndex(name => /\uC678\uAD6D\uC778/i.test(name));
      if (idx >= 0) return idx;
      idx = header.findIndex(name => /\uCD1D\s*\uD569\uACC4|\uD569\uACC4/i.test(name));
      if (idx >= 0) return idx;
      return 0;
    }
    function applyComputedTotal(metrics, header, totalLabel){
      const totalIdx = findTotalIndex(header, totalLabel);
      if (totalIdx < 0) return metrics;
      const total = metrics.reduce((sum, value, idx) => (idx === totalIdx ? sum : sum + (value || 0)), 0);
      metrics[totalIdx] = total;
      return metrics;
    }
    function updateEntryTotal(){
      if (isUpdatingTotal) return;
      const header = getActiveHeader();
      const meta = getActiveMeta();
      const totalIdx = findTotalIndex(header, meta.totalLabel);
      if (totalIdx < 0) return;
      isUpdatingTotal = true;
      try{
        const metrics = collectEntryMetrics();
        const total = metrics.reduce((sum, value, i) => (i === totalIdx ? sum : sum + value), 0);
        const totalInput = document.getElementById(`metric-${totalIdx}`);
        if (totalInput){
          totalInput.value = total;
        }
      }finally{
        isUpdatingTotal = false;
      }
    }
    function getEntryDateISO(){
      if (!entryDateInput) return "";
      const date = parseDateString(entryDateInput.value);
      if (!date) return "";
      return formatISO(date);
    }
    function handleEntryDateChange(){
      const dateISO = getEntryDateISO();
      if (!dateISO) return;
      selectedDateISO = dateISO;
      prefillEntry(dateISO);
      setDailySelection(dateISO);
    }
    function selectEntryDate(dateISO){
      if (!entryDateInput) return;
      entryDateInput.value = dateISO;
      selectedDateISO = dateISO;
      prefillEntry(dateISO);
      updateEntryTotal();
      if (entryPanel && entryPanel.classList.contains("hidden")){
        entryPanel.classList.remove("hidden");
      }
      if (entryPanel && entryPanel.scrollIntoView){
        entryPanel.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }
    function setDailySelection(dateISO){
      const dailyBody = document.getElementById("dailyBody");
      if (!dailyBody) return;
      dailyBody.querySelectorAll("tr").forEach(row => {
        const isMatch = dateISO && row.getAttribute("data-date") === dateISO;
        row.classList.toggle("selected", isMatch);
      });
    }

    function buildEntryFields(){
      const header = getActiveHeader();
      if (!header.length){
        entryFields.innerHTML = '<div class="msg">\uD5E4\uB354 \uC815\uBCF4\uAC00 \uC5C6\uC2B5\uB2C8\uB2E4.</div>';
        return;
      }
      const meta = getActiveMeta();
      const totalIdx = findTotalIndex(header, meta.totalLabel);
      const prevDate = entryDateInput ? entryDateInput.value : "";
      const headCells = header.map((name, idx) => {
        const cls = idx === totalIdx ? "total-cell" : "";
        return `<th class="${cls}">${name}</th>`;
      }).join("");
      const inputCells = header.map((_, idx) => {
        const id = `metric-${idx}`;
        const readonly = idx === totalIdx ? "readonly" : "";
        const cls = idx === totalIdx ? "total-cell" : "";
        return `<td class="${cls}"><input id="${id}" type="number" min="0" step="1" placeholder="0" ${readonly} /></td>`;
      }).join("");
      entryFields.innerHTML = `
        <div class="entry-scroll">
          <table class="entry-table">
            <thead>
              <tr>
                <th>ÎÇ†Ïßú</th>
                ${headCells}
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><input id="entryDate" type="date" /></td>
                ${inputCells}
              </tr>
            </tbody>
          </table>
        </div>
      `;
      entryDateInput = document.getElementById("entryDate");
      if (prevDate) entryDateInput.value = prevDate;
      entryDateInput.addEventListener("change", handleEntryDateChange);
      entryDateInput.addEventListener("blur", handleEntryDateChange);
      entryFields.querySelectorAll("input[id^='metric-']").forEach(input => {
        if (input.hasAttribute("readonly")) return;
        input.addEventListener("input", updateEntryTotal);
      });
      updateEntryTotal();
      renderForeignHeaderManager();
    }
    function clearEntryFields(){
      entryFields.querySelectorAll("input[id^='metric-']").forEach(input => { input.value = ""; });
      updateEntryTotal();
    }
    function prefillEntry(dateISO){
      if (!dateISO) return;
      const row = state.rowsByDate[dateISO];
      const header = getActiveHeader();
      const key = getActiveMetricsKey();
      if (!row){
        clearEntryFields();
        return;
      }
      let raw = [];
      if (key === "metrics"){
        raw = row && row.metrics ? row.metrics : row;
      }else if (key === "surgeryMetrics"){
        const hasSurgeryMetrics = row && typeof row === "object" && !Array.isArray(row) && Object.prototype.hasOwnProperty.call(row, "surgeryMetrics");
        if (!hasSurgeryMetrics){
          clearEntryFields();
          return;
        }
        raw = row.surgeryMetrics;
      }else{
        raw = row && row.foreignMetrics ? row.foreignMetrics : [];
      }
      const metrics = normalizeMetrics(raw, header.length);
      metrics.forEach((val, idx) => {
        const input = document.getElementById(`metric-${idx}`);
        if (input) input.value = ((val === undefined || val === null) ? 0 : val);
      });
      updateEntryTotal();
    }
    function collectEntryMetrics(){
      const header = getActiveHeader();
      return header.map((_, idx) => {
        const input = document.getElementById(`metric-${idx}`);
        return toNumber(input ? input.value : 0);
      });
    }
    function buildRowPayload(dateISO, metrics, tab){
      const existing = state.rowsByDate[dateISO];
      const visitHeader = state.header;
      const surgeryHeader = getHeaderByTab(TAB_SURGERY);
      const foreignHeader = state.foreignHeader;
      const existingVisit = normalizeMetrics(existing && existing.metrics ? existing.metrics : existing, visitHeader.length);
      const hasSurgeryMetrics = existing && typeof existing === "object" && !Array.isArray(existing) && Object.prototype.hasOwnProperty.call(existing, "surgeryMetrics");
      const existingSurgery = normalizeMetrics(hasSurgeryMetrics ? existing.surgeryMetrics : [], surgeryHeader.length);
      const existingForeign = normalizeMetrics(existing && existing.foreignMetrics ? existing.foreignMetrics : [], foreignHeader.length);
      const nextVisit = tab === TAB_VISITS ? normalizeMetrics(metrics, visitHeader.length) : existingVisit;
      const nextSurgery = tab === TAB_SURGERY ? normalizeMetrics(metrics, surgeryHeader.length) : existingSurgery;
      const nextForeign = tab === TAB_FOREIGN ? normalizeMetrics(metrics, foreignHeader.length) : existingForeign;
      applyComputedTotal(nextVisit, visitHeader, TAB_META[TAB_VISITS].totalLabel);
      applyComputedTotal(nextSurgery, surgeryHeader, TAB_META[TAB_SURGERY].totalLabel);
      applyComputedTotal(nextForeign, foreignHeader, TAB_META[TAB_FOREIGN].totalLabel);
      const nextPayload = { metrics: nextVisit, foreignMetrics: nextForeign };
      if (tab === TAB_SURGERY || hasSurgeryMetrics){
        nextPayload.surgeryMetrics = nextSurgery;
      }
      return nextPayload;
    }
    async function saveEntry(){
      const dateISO = getEntryDateISO();
      if (!dateISO){
        setMsg("ÎÇ†Ïßú ÌòïÏãùÏùÑ ÌôïÏù∏ÌïòÏÑ∏Ïöî. Ïòà: 2025.1.2", "error");
        return;
      }
      updateEntryTotal();
      const metrics = collectEntryMetrics();
      const payload = buildRowPayload(dateISO, metrics, activeTab);
      if (DATA_MODE === "local"){
        updateLocalRow(dateISO, payload);
        setMsg("Î°úÏª¨ Ï†ÄÏû• ÏôÑÎ£å", "success");
        return;
      }
      try{
        btnEntrySave.disabled = true;
        await set(ref(db, `${DB_ROOT}/rows/${dateISO}`), { ...payload, updatedAt: serverTimestamp() });
        setMsg("Ï†ÄÏû• ÏôÑÎ£å", "success");
      }catch(err){
        setMsg(`Ï†ÄÏû• Ïã§Ìå®: ${err.message || err}`, "error");
      }finally{
        btnEntrySave.disabled = false;
      }
    }
    async function deleteEntry(){
      const dateISO = selectedDateISO || getEntryDateISO();
      if (!dateISO){
        setMsg("ÏÇ≠Ï†úÌï† ÎÇ†ÏßúÎ•º ÏÑ†ÌÉùÌïòÏÑ∏Ïöî.", "error");
        return;
      }
      if (!confirm(`${dateISO} Îç∞Ïù¥ÌÑ∞Î•º ÏÇ≠Ï†úÌï†ÍπåÏöî? (Ìï¥Îãπ ÎÇ†Ïßú Ï†ÑÏ≤¥ ÏÇ≠Ï†ú)`)) return;
      if (DATA_MODE === "local"){
        const store = loadLocalStore();
        if (store.rows && store.rows[dateISO]){
          delete store.rows[dateISO];
          saveLocalStore(store);
          applyLocalStore(store, getEmbeddedData());
        }
        if (entryDateInput) entryDateInput.value = "";
        selectedDateISO = "";
        setDailySelection("");
        setMsg("ÏÇ≠Ï†ú ÏôÑÎ£å", "success");
        return;
      }
      try{
        btnDeleteRow.disabled = true;
        await remove(ref(db, `${DB_ROOT}/rows/${dateISO}`));
        if (entryDateInput) entryDateInput.value = "";
        selectedDateISO = "";
        setDailySelection("");
        setMsg("ÏÇ≠Ï†ú ÏôÑÎ£å", "success");
      }catch(err){
        setMsg(`ÏÇ≠Ï†ú Ïã§Ìå®: ${err.message || err}`, "error");
      }finally{
        btnDeleteRow.disabled = false;
      }
    }
    function setDefaultRange(rows){
      if (!rows.length || hasCustomRange) return;
      if (startInput.value || endInput.value) return;
      const today = new Date();
      const rangeStart = new Date(today.getFullYear(), today.getMonth(), today.getDate() - 29);
      const rangeEnd = new Date(today.getFullYear(), today.getMonth(), today.getDate());
      const hasRecent = rows.some(row => row.date && row.date >= rangeStart && row.date <= rangeEnd);
      if (hasRecent){
        startInput.value = formatISO(rangeStart);
        endInput.value = formatISO(rangeEnd);
        return;
      }
      const minDate = rows[0].date;
      const maxDate = rows[rows.length - 1].date;
      startInput.value = formatISO(minDate);
      endInput.value = formatISO(maxDate);
    }
    function getActiveRows(){
      const header = getActiveHeader();
      const key = getActiveMetricsKey();
      const rows = state.rows.map(row => ({
        ...row,
        metrics: normalizeMetrics(row[key], header.length)
      }));
      if (activeTab === TAB_SURGERY){
        return rows.filter(row => row.hasSurgeryMetrics);
      }
      return rows;
    }
    function getFilteredRows(rows){
      const startVal = startInput.value;
      const endVal = endInput.value;
      const start = startVal ? new Date(`${startVal}T00:00:00`) : null;
      const end = endVal ? new Date(`${endVal}T23:59:59`) : null;
      const list = rows || getActiveRows();
      return list.filter(row => {
        if (!row.date) return false;
        if (start && row.date < start) return false;
        if (end && row.date > end) return false;
        return true;
      });
    }
    function calcSums(rows, header){
      const sums = new Array(header.length).fill(0);
      rows.forEach(row => {
        row.metrics.forEach((value, idx) => { sums[idx] += value || 0; });
      });
      return header.map((name, idx) => ({ name, value: sums[idx] }));
    }
    function renderCards(sums){
      if (!sums.length){
        document.getElementById("cards").innerHTML = "";
        return;
      }
      const header = getActiveHeader();
      const meta = getActiveMeta();
      const totalIdx = findTotalIndex(header, meta.totalLabel);
      const total = totalIdx >= 0 ? sums[totalIdx].value : sums.reduce((acc, cur) => acc + cur.value, 0);
      const topRoutes = sums.map((item, idx) => ({ ...item, idx }))
        .filter(item => item.idx !== totalIdx)
        .sort((a, b) => b.value - a.value)
        .slice(0, 3);
      let cardsHTML = `
      <div class=\"card\">
        <div class=\"t\">${meta.totalLabel}</div>
        <div class=\"v\">${fmt(total)}</div>
      </div>
    `;
      const medals = ["ü•á", "ü•à", "ü•â"];
      topRoutes.forEach((route, idx) => {
        cardsHTML += `
        <div class=\"card\">
          <div class=\"t\">${medals[idx]} ${route.name}</div>
          <div class=\"v\">${fmt(route.value)}</div>
        </div>
      `;
      });
      document.getElementById("cards").innerHTML = cardsHTML;
    }
    function renderSum(sums){
      document.getElementById("sumBody").innerHTML = sums.map(x => `
        <tr>
          <td>${x.name}</td>
          <td><b>${fmt(x.value)}</b></td>
        </tr>
      `).join("");
    }
    function sortTable(bodyId, colIndex){
      const tbody = document.getElementById(bodyId);
      if (!tbody) return;
      const rows = Array.from(tbody.querySelectorAll("tr"));
      const orderKey = `${bodyId}-${colIndex}`;
      sortTable.order = sortTable.order || {};
      const order = sortTable.order[orderKey] === "asc" ? "desc" : "asc";
      sortTable.order[orderKey] = order;
      rows.sort((a, b) => {
        const aVal = a.children[colIndex].textContent.trim();
        const bVal = b.children[colIndex].textContent.trim();
        const aNum = parseFloat(aVal.replace(/,/g, ""));
        const bNum = parseFloat(bVal.replace(/,/g, ""));
        if (!Number.isNaN(aNum) && !Number.isNaN(bNum)){
          return order === "asc" ? aNum - bNum : bNum - aNum;
        }
        return order === "asc" ? aVal.localeCompare(bVal) : bVal.localeCompare(aVal);
      });
      tbody.innerHTML = "";
      rows.forEach(row => tbody.appendChild(row));
      const headers = tbody.parentElement.querySelectorAll("th");
      headers.forEach((h, i) => {
        h.classList.remove("sorted");
        if (i === colIndex) h.classList.add("sorted");
      });
    }
    function renderDaily(rows){
      if (!rows || rows.length === 0){
        document.getElementById("dailyWrap").innerHTML = "<div class=\"msg\">ÌëúÏãúÌï† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.</div>";
        return;
      }
      const header = getActiveHeader();
      const th = ["ÎÇ†Ïßú", ...header].map((h, idx) => (
        `<th onclick="sortTable('dailyBody', ${idx})">${h} <span class=\"sort-icon\">&#8597;</span></th>`
      )).join("");
      const body = rows.map(row => {
        const label = row.date ? formatLabel(row.date) : row.dateISO;
        return `
          <tr data-date="${row.dateISO}">
            <td>${label}</td>
            ${row.metrics.map(v => `<td>${fmt(v)}</td>`).join("")}
          </tr>
        `;
      }).join("");
      document.getElementById("dailyWrap").innerHTML = `
      <table>
        <thead><tr>${th}</tr></thead>
        <tbody id=\"dailyBody\">${body}</tbody>
      </table>
    `;
      const dailyBody = document.getElementById("dailyBody");
      if (dailyBody){
        dailyBody.querySelectorAll("tr").forEach(row => {
          row.addEventListener("click", () => {
            const dateISO = row.getAttribute("data-date");
            if (dateISO){
              selectEntryDate(dateISO);
              setDailySelection(dateISO);
            }
          });
        });
        if (selectedDateISO){
          setDailySelection(selectedDateISO);
        }
      }
    }
function createTrendChart(rows){
      const ctx = document.getElementById("trendChart");
      if (!ctx) return;
      const header = getActiveHeader();
      const meta = getActiveMeta();
      const totalIdx = findTotalIndex(header, meta.totalLabel);
      const routeTotals = header.map((name, idx) => ({
        name,
        index: idx,
        total: rows.reduce((sum, row) => sum + (row.metrics[idx] || 0), 0)
      })).filter(route => route.index !== totalIdx);
      const top5Routes = routeTotals.sort((a, b) => b.total - a.total).slice(0, 5);
      const labels = rows.map(r => {
        const label = r.date ? formatLabel(r.date) : r.dateISO;
        return label.split(".").slice(1).join("/");
      });
      const datasets = top5Routes.map((route, i) => ({
        label: route.name,
        data: rows.map(r => r.metrics[route.index] || 0),
        borderWidth: 2,
        tension: 0.4,
        fill: false
      }));
      const colors = ["#2563eb", "#10b981", "#f59e0b", "#ef4444", "#8b5cf6"];
      datasets.forEach((ds, i) => {
        ds.borderColor = colors[i % colors.length];
        ds.backgroundColor = colors[i % colors.length];
      });
      if (trendChart) trendChart.destroy();
      trendChart = new Chart(ctx, {
        type: "line",
        data: { labels, datasets },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { position: "bottom", labels: { color: getComputedStyle(document.body).getPropertyValue("--text") } } },
          scales: {
            y: {
              beginAtZero: true,
              ticks: { color: getComputedStyle(document.body).getPropertyValue("--muted"), callback: value => value.toLocaleString() },
              grid: { color: getComputedStyle(document.body).getPropertyValue("--border") }
            },
            x: {
              ticks: {
                color: getComputedStyle(document.body).getPropertyValue("--muted"),
                maxRotation: 45,
                minRotation: 0,
                font: { size: 10 },
                autoSkip: true,
                maxTicksLimit: 15
              },
              grid: { color: getComputedStyle(document.body).getPropertyValue("--border") }
            }
          }
        }
      });
    }
    function createPieChart(sums){
      const ctx = document.getElementById("pieChart");
      if (!ctx) return;
      const header = getActiveHeader();
      const meta = getActiveMeta();
      const totalIdx = findTotalIndex(header, meta.totalLabel);
      const filtered = sums.filter((_, idx) => idx !== totalIdx);
      const labels = filtered.map(s => s.name);
      const data = filtered.map(s => s.value);
      const colors = ["#2563eb", "#10b981", "#f59e0b", "#ef4444", "#8b5cf6", "#06b6d4", "#f97316"];
      if (pieChart) pieChart.destroy();
      pieChart = new Chart(ctx, {
        type: "doughnut",
        data: { labels, datasets: [{ data, backgroundColor: colors, borderWidth: 2, borderColor: getComputedStyle(document.body).getPropertyValue("--panel") }] },
        options: { responsive: true, maintainAspectRatio: false, plugins: { legend: { position: "bottom", labels: { color: getComputedStyle(document.body).getPropertyValue("--text") } } } }
      });
    }
    function createTotalBarChart(rows){
      const ctx = document.getElementById("totalBarChart");
      if (!ctx) return;
      const header = getActiveHeader();
      const meta = getActiveMeta();
      const totalIdx = findTotalIndex(header, meta.totalLabel);
      const labels = rows.map(r => {
        const label = r.date ? formatLabel(r.date) : r.dateISO;
        const parts = label.split(".");
        if (parts.length >= 3) return `${parts[1]}/${parts[2]}`;
        return label;
      });
      const totalData = rows.map(r => totalIdx >= 0 ? r.metrics[totalIdx] || 0 : r.metrics.reduce((sum, val) => sum + (val || 0), 0));
      if (totalBarChart) totalBarChart.destroy();
      totalBarChart = new Chart(ctx, {
        type: "bar",
        data: { labels, datasets: [{ label: meta.totalLabel, data: totalData, backgroundColor: "rgba(37, 99, 235, 0.7)", borderColor: "#2563eb", borderWidth: 2, borderRadius: 6 }] },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: { legend: { display: false }, tooltip: { callbacks: { label: context => `${meta.totalLabel} ${context.parsed.y.toLocaleString()}Î™Ö` } } },
          scales: {
            y: {
              beginAtZero: true,
              ticks: { color: getComputedStyle(document.body).getPropertyValue("--muted"), callback: value => value.toLocaleString() },
              grid: { color: getComputedStyle(document.body).getPropertyValue("--border") }
            },
            x: {
              ticks: {
                color: getComputedStyle(document.body).getPropertyValue("--muted"),
                maxRotation: 90,
                minRotation: 45,
                font: { size: 10 },
                autoSkip: true,
                maxTicksLimit: 20
              },
              grid: { display: false }
            }
          }
        }
      });
    }
    function updateChartTheme(){
      if (!trendChart) return;
      const textColor = getComputedStyle(document.body).getPropertyValue("--text");
      const mutedColor = getComputedStyle(document.body).getPropertyValue("--muted");
      const borderColor = getComputedStyle(document.body).getPropertyValue("--border");
      trendChart.options.plugins.legend.labels.color = textColor;
      trendChart.options.scales.y.ticks.color = mutedColor;
      trendChart.options.scales.x.ticks.color = mutedColor;
      trendChart.options.scales.y.grid.color = borderColor;
      trendChart.options.scales.x.grid.color = borderColor;
      trendChart.update();
    }
    function updatePieChartTheme(){
      if (!pieChart) return;
      const textColor = getComputedStyle(document.body).getPropertyValue("--text");
      const panelColor = getComputedStyle(document.body).getPropertyValue("--panel");
      pieChart.options.plugins.legend.labels.color = textColor;
      pieChart.data.datasets[0].borderColor = panelColor;
      pieChart.update();
    }
    function updateTotalBarChartTheme(){
      if (!totalBarChart) return;
      const mutedColor = getComputedStyle(document.body).getPropertyValue("--muted");
      const borderColor = getComputedStyle(document.body).getPropertyValue("--border");
      totalBarChart.options.scales.y.ticks.color = mutedColor;
      totalBarChart.options.scales.x.ticks.color = mutedColor;
      totalBarChart.options.scales.y.grid.color = borderColor;
      totalBarChart.update();
    }
    function renderAll(){
      const header = getActiveHeader();
      if (!header.length){
        setMsg("Ìó§Îçî Ï†ïÎ≥¥Î•º Î∂àÎü¨Ïò§Îäî Ï§ë...", "");
        return;
      }
      const rows = getFilteredRows(getActiveRows());
      const sums = calcSums(rows, header);
      renderCards(sums);
      renderSum(sums);
      renderDaily(rows);
      createTotalBarChart(rows);
      createTrendChart(rows);
      createPieChart(sums);
      if (!rows.length){
        setMsg("ÌëúÏãúÌï† Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.", "error");
      }else{
        setMsg("Ï°∞Ìöå ÏôÑÎ£å", "success");
      }
    }
    function setPreset(type){
      const today = new Date();
      const start = new Date();
      const end = new Date();
      switch(type){
        case "today":
          start.setDate(today.getDate());
          break;
        case "week":
          start.setDate(today.getDate() - 6);
          break;
        case "month":
          start.setDate(1);
          break;
        case "lastMonth":
          start.setMonth(today.getMonth() - 1);
          start.setDate(1);
          end.setDate(0);
          break;
      }
      startInput.value = formatISO(start);
      endInput.value = formatISO(end);
      hasCustomRange = true;
      load();
    }
    function load(){ hasCustomRange = true; renderAll(); }
    function toggleTheme(){
      const html = document.documentElement;
      const current = html.getAttribute("data-theme");
      const next = current === "dark" ? "light" : "dark";
      html.setAttribute("data-theme", next);
      localStorage.setItem("theme", next);
      themeToggle.textContent = next === "dark" ? "‚òÄÔ∏è" : "üåô";
      updateChartTheme();
      updatePieChartTheme();
      updateTotalBarChartTheme();
    }
    function parseCSV(text){
      const rows = [];
      let row = [];
      let current = "";
      let inQuotes = false;
      for (let i = 0; i < text.length; i++){
        const char = text[i];
        const next = text[i + 1];
        if (char === '"' && inQuotes && next === '"'){
          current += '"';
          i++;
          continue;
        }
        if (char === '"'){
          inQuotes = !inQuotes;
          continue;
        }
        if (char === "," && !inQuotes){
          row.push(current);
          current = "";
          continue;
        }
        if ((char === "\n" || char === "\r") && !inQuotes){
          if (char === "\r" && next === "\n") i++;
          row.push(current);
          if (row.length > 1 || row[0].trim() !== "") rows.push(row);
          row = [];
          current = "";
          continue;
        }
        current += char;
      }
      if (current.length || row.length){
        row.push(current);
        rows.push(row);
      }
      return rows;
    }
    function extractCSVData(rows){
      const headerIdx = rows.findIndex(r => /ÎÇ†Ïßú|date/i.test(String(r[0] || "").trim()));
      if (headerIdx < 0) throw new Error("CSVÏóêÏÑú Ìó§Îçî(ÎÇ†Ïßú Ìñâ)Î•º Ï∞æÏßÄ Î™ªÌñàÏäµÎãàÎã§.");
      const header = rows[headerIdx].slice(1).map(v => String(v || "").trim()).filter(Boolean);
      const dataRows = rows.slice(headerIdx + 1);
      const mapped = {};
      dataRows.forEach(row => {
        const dateRaw = row[0];
        const date = parseDateString(dateRaw);
        if (!date) return;
        const dateISO = formatISO(date);
        const metrics = header.map((_, idx) => toNumber(row[idx + 1]));
        mapped[dateISO] = { metrics, updatedAt: serverTimestamp() };
      });
      return { header, rows: mapped };
    }
    function loadLocalStore(){
      try{
        return JSON.parse(localStorage.getItem(STORAGE_KEY) || "{}");
      }catch(err){
        return {};
      }
    }
    function saveLocalStore(data){
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data || {}));
    }
    function getEmbeddedData(){
      if (!EMBEDDED_CSV || !EMBEDDED_CSV.trim()) return null;
      try{
        const text = EMBEDDED_CSV.replace(/^\uFEFF/, "");
        return extractCSVData(parseCSV(text));
      }catch(err){
        return null;
      }
    }
    function applyLocalStore(store, embedded){
      const base = embedded || null;
      const header = (store && Array.isArray(store.header) && store.header.length)
        ? store.header
        : (base && base.header && base.header.length ? base.header : DEFAULT_HEADER);
      const foreignHeader = (store && Array.isArray(store.foreignHeader) && store.foreignHeader.length)
        ? store.foreignHeader
        : DEFAULT_FOREIGN_HEADER;
      const normalizedForeignHeader = isPlaceholderForeignHeader(foreignHeader)
        ? DEFAULT_FOREIGN_HEADER
        : normalizeForeignHeader(foreignHeader);
      const rowsByDate = {
        ...(base && base.rows ? base.rows : {}),
        ...(store && store.rows ? store.rows : {})
      };
      state.header = header;
      state.foreignHeader = normalizedForeignHeader;
      state.rowsByDate = rowsByDate;
      rebuildRows();
      buildEntryFields();
      setDefaultRange(state.rows);
      renderAll();
    }
    function rebuildRows(){
      const surgeryHeader = getHeaderByTab(TAB_SURGERY);
      state.rows = Object.entries(state.rowsByDate).map(([dateISO, payload]) => {
        const date = parseDateString(dateISO);
        const metrics = normalizeMetrics(payload && payload.metrics ? payload.metrics : payload, state.header.length);
        const hasSurgeryMetrics = payload && typeof payload === "object" && !Array.isArray(payload) && Object.prototype.hasOwnProperty.call(payload, "surgeryMetrics");
        const surgeryMetrics = normalizeMetrics(hasSurgeryMetrics ? payload.surgeryMetrics : [], surgeryHeader.length);
        const foreignMetrics = normalizeMetrics(payload && payload.foreignMetrics ? payload.foreignMetrics : [], state.foreignHeader.length);
        applyComputedTotal(metrics, state.header, TAB_META[TAB_VISITS].totalLabel);
        applyComputedTotal(surgeryMetrics, surgeryHeader, TAB_META[TAB_SURGERY].totalLabel);
        applyComputedTotal(foreignMetrics, state.foreignHeader, TAB_META[TAB_FOREIGN].totalLabel);
        return { dateISO, date, metrics, surgeryMetrics, hasSurgeryMetrics, foreignMetrics };
      }).filter(row => row.date).sort((a, b) => a.date - b.date);
    }
    function initLocal(){
      const embedded = getEmbeddedData();
      const store = loadLocalStore();
      applyLocalStore(store, embedded);
    }
    function updateLocalRow(dateISO, payload){
      const store = loadLocalStore();
      store.header = state.header;
      store.foreignHeader = state.foreignHeader;
      store.rows = store.rows || {};
      store.rows[dateISO] = { ...payload, updatedAt: Date.now() };
      saveLocalStore(store);
      applyLocalStore(store, getEmbeddedData());
    }
    async function seedFromEmbeddedCsv(headerRef, rowsRef){
      if (seedAttempted) return;
      seedAttempted = true;
      if (!EMBEDDED_CSV || !EMBEDDED_CSV.trim()) return;
      try{
        const text = EMBEDDED_CSV.replace(/^Ôªø/, "");
        const parsed = extractCSVData(parseCSV(text));
        await set(headerRef, parsed.header);
        await update(rowsRef, parsed.rows);
        setMsg("Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞Î•º Ï†ÅÏö©ÌñàÏäµÎãàÎã§.", "success");
      }catch(err){
        setMsg(`Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞ Ï†ÅÏö© Ïã§Ìå®: ${err.message || err}`, "error");
      }
    }
    function subscribe(){
      setMsg("Firebase Ïó∞Í≤∞ Ï§ë...", "");
      const headerRef = ref(db, `${DB_ROOT}/meta/header`);
      const foreignHeaderRef = ref(db, `${DB_ROOT}/meta/foreignHeader`);
      const rowsRef = ref(db, `${DB_ROOT}/rows`);
      onValue(headerRef, snapshot => {
        const header = normalizeHeader(snapshot.val());
        headerEmpty = header.length === 0;
        if (headerEmpty){
          state.header = [...DEFAULT_HEADER];
          if (rowsEmpty){
            seedFromEmbeddedCsv(headerRef, rowsRef);
          }else{
            set(headerRef, state.header).catch(() => {});
          }
        }else{
          state.header = header;
        }
        if (!headerEmpty){
          const migrated = migrateSearchColumns(header, state.rowsByDate);
          if (migrated.migrated){
            state.header = migrated.header;
            state.rowsByDate = migrated.rowsByDate;
            migratedSearchColumns = true;
          }
          const metaMigrated = migrateMetaLabel(state.header, state.rowsByDate);
          if (metaMigrated.migrated){
            state.header = metaMigrated.header;
            migratedSearchColumns = true;
          }
          const googleAdMigrated = migrateGoogleAdColumn(state.header, state.rowsByDate);
          if (googleAdMigrated.migrated){
            state.header = googleAdMigrated.header;
            state.rowsByDate = googleAdMigrated.rowsByDate;
            migratedSearchColumns = true;
          }
        }
        rebuildRows();
        buildEntryFields();
        renderAll();
      });
      onValue(foreignHeaderRef, snapshot => {
        const foreignHeader = normalizeHeader(snapshot.val());
        foreignHeaderEmpty = foreignHeader.length === 0;
        if (foreignHeaderEmpty){
          state.foreignHeader = [...DEFAULT_FOREIGN_HEADER];
          set(foreignHeaderRef, state.foreignHeader).catch(() => {});
        }else{
          let nextForeignHeader = isPlaceholderForeignHeader(foreignHeader)
            ? [...DEFAULT_FOREIGN_HEADER]
            : foreignHeader;
          nextForeignHeader = normalizeForeignHeader(nextForeignHeader);
          state.foreignHeader = nextForeignHeader;
          if (JSON.stringify(nextForeignHeader) !== JSON.stringify(foreignHeader)){
            set(foreignHeaderRef, nextForeignHeader).catch(() => {});
          }
        }
        rebuildRows();
        buildEntryFields();
        renderAll();
      });
      onValue(rowsRef, snapshot => {
        state.rowsByDate = snapshot.val() || {};
        if (!migratedSearchColumns){
          const migrated = migrateSearchColumns(state.header, state.rowsByDate);
          if (migrated.migrated){
            state.header = migrated.header;
            state.rowsByDate = migrated.rowsByDate;
            migratedSearchColumns = true;
          }
          const metaMigrated = migrateMetaLabel(state.header, state.rowsByDate);
          if (metaMigrated.migrated){
            state.header = metaMigrated.header;
            migratedSearchColumns = true;
          }
          const googleAdMigrated = migrateGoogleAdColumn(state.header, state.rowsByDate);
          if (googleAdMigrated.migrated){
            state.header = googleAdMigrated.header;
            state.rowsByDate = googleAdMigrated.rowsByDate;
            migratedSearchColumns = true;
          }
        }
        rowsEmpty = Object.keys(state.rowsByDate).length === 0;
        if (rowsEmpty && headerEmpty){
          seedFromEmbeddedCsv(headerRef, rowsRef);
        }
        if (migratedSearchColumns){
          const headerRef = ref(db, `${DB_ROOT}/meta/header`);
          const rowsRef = ref(db, `${DB_ROOT}/rows`);
          set(headerRef, state.header).catch(() => {});
          update(rowsRef, state.rowsByDate).catch(() => {});
          migratedSearchColumns = false;
        }
        rebuildRows();
        setDefaultRange(state.rows);
        renderAll();
      });
    }
    function init(){
      const savedTheme = localStorage.getItem("theme") || "light";
      const savedTab = localStorage.getItem("activeTab");
      if (TAB_META[savedTab]) activeTab = savedTab;
      document.documentElement.setAttribute("data-theme", savedTheme);
      themeToggle.textContent = savedTheme === "dark" ? "‚òÄÔ∏è" : "üåô";
      themeToggle.addEventListener("click", toggleTheme);
      document.querySelectorAll(".tab-btn").forEach(btn => {
        btn.addEventListener("click", () => setActiveTab(btn.dataset.tab));
      });
      updateTabUI();
      toggleEntryBtn.addEventListener("click", () => { entryPanel.classList.toggle("hidden"); });
      btnEntrySave.addEventListener("click", saveEntry);
      btnEntryClear.addEventListener("click", clearEntryFields);
      btnDeleteRow.addEventListener("click", deleteEntry);
      if (btnAddForeignHeader){
        btnAddForeignHeader.addEventListener("click", addForeignHeaderItem);
      }
      if (foreignHeaderInput){
        foreignHeaderInput.addEventListener("keydown", event => {
          if (event.key !== "Enter") return;
          event.preventDefault();
          addForeignHeaderItem();
        });
      }
      if (foreignHeaderList){
        foreignHeaderList.addEventListener("click", event => {
          const target = event.target instanceof Element ? event.target : null;
          if (!target) return;
          const removeBtn = target.closest("button[data-remove-index]");
          if (!removeBtn) return;
          const removeIndex = Number(removeBtn.dataset.removeIndex);
          removeForeignHeaderItem(removeIndex);
        });
      }
      startInput.addEventListener("change", () => { hasCustomRange = true; });
      endInput.addEventListener("change", () => { hasCustomRange = true; });
      if (DATA_MODE === "local"){
        initLocal();
      }else{
        subscribe();
      }
    }
    window.load = load;
    window.setPreset = setPreset;
    window.toggleTheme = toggleTheme;
    window.sortTable = sortTable;
    init();
  </script>
</body>
</html>
